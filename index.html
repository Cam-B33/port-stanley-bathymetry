<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Port Stanley Nearshore Bathymetry</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Computer+Modern+Serif:wght@400;700&family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #fefefe;
            --bg-secondary: #f8f8f8;
            --text-primary: #1a1a1a;
            --text-secondary: #555;
            --accent: #2563eb;
            --border: #ddd;
            --code-bg: #f5f5f5;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Computer Modern Serif', 'Georgia', serif;
            line-height: 1.7;
            color: var(--text-primary);
            background: var(--bg-primary);
            max-width: 1200px;
            margin: 0 auto;
            padding: 3rem 2rem;
        }
        
        header {
            border-bottom: 2px solid var(--text-primary);
            padding-bottom: 1.5rem;
            margin-bottom: 3rem;
        }
        
        h1 {
            font-size: 2.2rem;
            font-weight: 700;
            letter-spacing: -0.02em;
            margin-bottom: 0.5rem;
        }
        
        .subtitle {
            font-size: 1.1rem;
            color: var(--text-secondary);
            font-style: italic;
        }
        
        nav {
            margin-top: 1.5rem;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9rem;
        }
        
        nav a {
            color: var(--text-primary);
            text-decoration: none;
            margin-right: 2rem;
            border-bottom: 1px solid transparent;
            transition: border-color 0.2s;
        }
        
        nav a:hover,
        nav a.active {
            border-bottom: 1px solid var(--text-primary);
        }
        
        main {
            margin-bottom: 4rem;
        }
        
        section {
            margin-bottom: 4rem;
        }
        
        h2 {
            font-size: 1.6rem;
            margin-bottom: 1rem;
            font-weight: 700;
        }
        
        h3 {
            font-size: 1.2rem;
            margin: 1.5rem 0 0.75rem;
            font-weight: 600;
        }
        
        p {
            margin-bottom: 1rem;
        }
        
        .map-container {
            width: 100%;
            height: 600px;
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            margin: 2rem 0 0 0;  /* Remove bottom margin, we'll add it to attribution */
            position: relative;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        #map {
            width: 100%;
            height: 100%;
        }
        
        /* Hide Leaflet's default attribution */
        .leaflet-control-attribution {
            display: none !important;
        }
        
        .map-info {
            background: var(--bg-secondary);
            padding: 1.5rem;
            border-left: 3px solid var(--accent);
            margin: 1.5rem 0;
        }
        
        .map-info h3 {
            margin-top: 0;
        }
        
        .date-updated {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        code {
            font-family: 'IBM Plex Mono', monospace;
            background: var(--code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-size: 0.9em;
        }
        
        pre {
            font-family: 'IBM Plex Mono', monospace;
            background: var(--code-bg);
            padding: 1.5rem;
            border-radius: 4px;
            overflow-x: auto;
            margin: 1.5rem 0;
            border-left: 3px solid var(--accent);
        }
        
        pre code {
            background: none;
            padding: 0;
        }
        
        .theorem {
            background: var(--bg-secondary);
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 3px solid var(--text-primary);
        }
        
        .theorem-title {
            font-weight: 600;
            font-style: italic;
            margin-bottom: 0.5rem;
        }
        
        a {
            color: var(--accent);
            text-decoration: none;
            border-bottom: 1px solid transparent;
        }
        
        a:hover {
            border-bottom: 1px solid var(--accent);
        }
        
        footer {
            border-top: 1px solid var(--border);
            padding-top: 2rem;
            margin-top: 4rem;
            font-size: 0.9rem;
            color: var(--text-secondary);
            text-align: center;
        }
        
        .github-link {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9rem;
        }
        
        .image-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin: 2rem 0;
        }
        
        .image-card {
            border: 1px solid var(--border);
            overflow: hidden;
        }
        
        .image-card img {
            width: 100%;
            display: block;
        }
        
        .image-card figcaption {
            padding: 1rem;
            font-size: 0.9rem;
            color: var(--text-secondary);
            background: var(--bg-secondary);
        }
        
        .hidden {
            display: none;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 2rem 1rem;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            nav a {
                display: block;
                margin: 0.5rem 0;
            }
            
            .map-container {
                height: 400px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Port Stanley Nearshore Bathymetry</h1>
        <p class="subtitle">Satellite-derived rip current mapping for beach safety</p>
        <nav>
            <a href="#" class="nav-link active" data-section="dashboard">Dashboard</a>
            <a href="#" class="nav-link" data-section="methodology">Methodology</a>
            <a href="#" class="nav-link" data-section="code">Code</a>
        </nav>
    </header>

    <main>
        <!-- Dashboard Section -->
        <section id="dashboard-section">
            <h2>Current Bathymetry Map</h2>
            
            <div class="map-info">
                <h3>Lake Erie ‚Äî Port Stanley Main Beach</h3>
                <p class="date-updated">Last updated: <strong id="last-update-date">2024-09-30</strong></p>
                <p>This map shows relative nearshore bathymetry derived from Sentinel-2 satellite imagery. Darker channels indicate deeper water where rip currents are likely to form.</p>
            </div>

            <div class="map-container">
                <div id="map"></div>
                <canvas id="flow-canvas" style="position: absolute; top: 0; left: 0; pointer-events: none; z-index: 1000;"></canvas>
                
                <!-- Flow Control Panel -->
                <div id="flow-controls" style="position: absolute; top: 10px; left: 10px; background: white; padding: 15px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.2); z-index: 1001; font-family: 'IBM Plex Mono', monospace; font-size: 0.85rem;">
                    <div style="margin-bottom: 10px; font-weight: 600;">Rip Current Flow</div>
                    <label style="display: block; margin-bottom: 8px; cursor: pointer;">
                        <input type="radio" name="flow-mode" value="off" checked> Off
                    </label>
                    <label style="display: block; margin-bottom: 8px; cursor: pointer;">
                        <input type="radio" name="flow-mode" value="east"> East Current
                    </label>
                    <label style="display: block; margin-bottom: 8px; cursor: pointer;">
                        <input type="radio" name="flow-mode" value="west"> West Current
                    </label>
                    <label style="display: block; margin-bottom: 8px; cursor: pointer;">
                        <input type="radio" name="flow-mode" value="offshore"> Onshore Flow
                    </label>
                    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #ddd; font-size: 0.75rem; color: #666;">
                        <strong>Heat map legend:</strong><br>
                        üü¢ Safe ‚Ä¢ üü° Low risk<br>
                        üü† Moderate ‚Ä¢ üî¥ Danger
                    </div>
                </div>
            </div>
            
            <!-- Map Attribution & Info (outside the map) -->
            <div style="margin-top: 15px; padding: 10px; background: #f8f8f8; border-radius: 5px; font-size: 0.8rem; color: #666;">
                <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                    <div>
                        <strong>Map data:</strong> ¬© OpenStreetMap contributors | 
                        <strong>Satellite:</strong> Esri, Maxar, Earthstar Geographics
                    </div>
                    <div>
                        <strong>Bathymetry:</strong> Sentinel-2 satellite imagery (10m resolution)
                    </div>
                </div>
            </div>

            <div class="map-info">
                <h3>Reading the Map</h3>
                <p><strong>Light areas:</strong> Shallow water (sandbars)</p>
                <p><strong>Dark channels:</strong> Deeper water where rip currents typically flow</p>
                <p><strong>Purple contours:</strong> Depth intervals showing underwater topography</p>
            </div>

            <h3>Recent Imagery</h3>
            <div class="image-gallery" id="image-gallery">
                <!-- Images will be dynamically loaded here -->
            </div>
        </section>

        <!-- Methodology Section -->
        <section id="methodology-section" class="hidden">
            <h2>Methodology</h2>
            
            <h3>Overview</h3>
            <p>This project uses multispectral satellite imagery from the European Space Agency's Sentinel-2 constellation to map shallow water bathymetry. The technique exploits differential light penetration through water columns of varying depths.</p>

            <div class="theorem">
                <div class="theorem-title">Band Ratio Method</div>
                <p>Relative depth <em>Z</em> is approximated as:</p>
                <p style="text-align: center; margin: 1rem 0; font-style: italic;">
                    Z ‚âà ln(R<sub>green</sub>) / ln(R<sub>red</sub>)
                </p>
                <p>where R denotes reflectance in each spectral band.</p>
            </div>

            <h3>Physical Principles</h3>
            <p>Water absorbs light differentially by wavelength. Red light (620-670 nm) is absorbed more rapidly than green light (530-590 nm). In shallow water, bottom reflectance contributes to the upwelling radiance measured by the satellite sensor.</p>
            
            <p>The ratio of logarithmic reflectances normalizes for variations in water clarity and illumination while remaining sensitive to depth variations in the 0-10m range typical of nearshore environments.</p>

            <h3>Data Processing Pipeline</h3>
            <ol style="margin-left: 2rem;">
                <li><strong>Acquisition:</strong> Sentinel-2 Level-2A (atmospherically corrected) imagery at 10m spatial resolution</li>
                <li><strong>Band Selection:</strong> Blue (B02), Green (B03), and Red (B04) bands</li>
                <li><strong>Ratio Calculation:</strong> Log-ratio bathymetry algorithm</li>
                <li><strong>Clipping:</strong> Extract area of interest around Port Stanley Beach</li>
                <li><strong>Visualization:</strong> Generate contoured maps highlighting rip current pathways</li>
            </ol>

            <h3>Limitations</h3>
            <p>This method provides <em>relative</em> rather than absolute depth measurements. Accuracy degrades with increasing turbidity, wave action, and sun glint. Cloud cover precludes data acquisition. Temporal resolution is limited by satellite revisit frequency (5 days for Sentinel-2 constellation).</p>

            <h3>Rip Current Risk Analysis</h3>
            <p>The interactive heat map visualizes rip current formation potential by analyzing bathymetric gradients and flow convergence patterns. This physics-based approach identifies zones where water is likely to accelerate offshore.</p>

            <div class="theorem">
                <div class="theorem-title">Flow Dynamics</div>
                <p>The risk calculation incorporates three components:</p>
                <p style="margin-left: 1.5rem;">
                    <strong>1. Bathymetric gradient:</strong> ‚àáZ = (‚àÇZ/‚àÇx, ‚àÇZ/‚àÇy)<br>
                    <strong>2. Flow convergence:</strong> ‚àá¬∑<strong>u</strong> = ‚àÇu/‚àÇx + ‚àÇv/‚àÇy<br>
                    <strong>3. Offshore component:</strong> u<sub>‚ä•</sub> = <strong>u</strong>¬∑<strong>n</strong>
                </p>
                <p>where <strong>u</strong> is the velocity field normalized from bathymetric gradients and <strong>n</strong> is the shore-normal direction.</p>
            </div>

            <h4>Risk Modes</h4>
            <p><strong>East Current:</strong> Models conditions when longshore currents flow eastward (typical with southwest winds). Water flows parallel to shore until encountering deep channels, where it converges and accelerates offshore.</p>
            
            <p><strong>West Current:</strong> Models westward longshore flow (typical with northeast winds). Risk zones shift as flow patterns reverse along the beach.</p>
            
            <p><strong>Onshore Flow:</strong> Models pure bathymetry-driven rip currents independent of longshore drift. These represent the natural rip channels that persist across varying wave conditions.</p>

            <h4>Risk Calculation</h4>
            <p>For each grid cell, risk is computed as a weighted combination of:</p>
            <ul style="margin-left: 2rem;">
                <li><strong>Longshore flow component</strong> (40%): Magnitude of east/west current</li>
                <li><strong>Convergence</strong> (30%): Negative divergence indicating water piling up</li>
                <li><strong>Offshore flow</strong> (30%): Shore-perpendicular velocity component</li>
            </ul>
            
            <p>The final risk score is normalized to [0,1] and rendered as a color-coded heat map where red indicates high danger and green indicates safe conditions.</p>

            <h4>Visualization Parameters</h4>
            <p>The heat map employs Gaussian blur (œÉ = 25px) to create smooth, continuous risk zones that better represent the diffuse nature of rip current hazards. Cell size is calibrated to balance spatial resolution with visual clarity at typical zoom levels.</p>

            <h3>Limitations</h3>
            <p>This method provides <em>relative</em> rather than absolute depth measurements. Accuracy degrades with increasing turbidity, wave action, and sun glint. Cloud cover precludes data acquisition. Temporal resolution is limited by satellite revisit frequency (5 days for Sentinel-2 constellation).</p>
            
            <p>The rip current risk model assumes steady-state flow conditions and does not account for temporal variations in wave height, period, or tidal stage. Actual rip current activity depends on these factors in addition to bathymetry. The model serves as a baseline hazard assessment rather than a real-time prediction system.</p>

            <h3>References</h3>
            <p style="margin-left: 2rem; text-indent: -2rem; padding-left: 2rem;">
                Stumpf, R. P., Holderied, K., & Sinclair, M. (2003). Determination of water depth with high-resolution satellite imagery over variable bottom types. <em>Limnology and Oceanography</em>, 48(1), 547-556.
            </p>
            <p style="margin-left: 2rem; text-indent: -2rem; padding-left: 2rem;">
                Lyzenga, D. R. (1978). Passive remote sensing techniques for mapping water depth and bottom features. <em>Applied Optics</em>, 17(3), 379-383.
            </p>
            <p style="margin-left: 2rem; text-indent: -2rem; padding-left: 2rem;">
                MacMahan, J. H., Thornton, E. B., & Reniers, A. J. (2006). Rip current review. <em>Coastal Engineering</em>, 53(2-3), 191-208.
            </p>
        </section>

        <!-- Code Section -->
        <section id="code-section" class="hidden">
            <h2>Open Source Implementation</h2>
            
            <p>The complete processing pipeline is available as an open-source Python command-line tool. The code is designed to be reproducible and easily adaptable to other nearshore environments.</p>

            <h3>Installation</h3>
            <pre><code># Clone repository
git clone https://github.com/Cam-B33/port-stanley-bathymetry.git
cd port-stanley-bathymetry

# Install dependencies
pip install -r requirements.txt</code></pre>

            <h3>Basic Usage</h3>
            <pre><code># Process a Sentinel-2 scene
python sentinel_bathymetry.py process \
    --scene /path/to/S2_SAFE_folder \
    --aoi aoi.geojson \
    --output port_stanley_2024_06_10</code></pre>

            <h3>Automated Processing</h3>
            <p>The system can automatically download and process new imagery every 10 days:</p>
            <pre><code># Download and process recent imagery
python sentinel_bathymetry.py download-and-process \
    --aoi aoi.geojson \
    --start-date 20240601 \
    --end-date 20240610 \
    --username your_copernicus_username \
    --password your_password</code></pre>

            <h3>Key Dependencies</h3>
            <ul style="margin-left: 2rem;">
                <li><code>rasterio</code> ‚Äî Geospatial raster I/O</li>
                <li><code>numpy</code> ‚Äî Numerical computing</li>
                <li><code>sentinelsat</code> ‚Äî Sentinel-2 data access</li>
                <li><code>matplotlib</code> ‚Äî Visualization</li>
            </ul>

            <h3>Repository Structure</h3>
            <pre><code>port-stanley-bathymetry/
‚îú‚îÄ‚îÄ sentinel_bathymetry.py    # Main processing script
‚îú‚îÄ‚îÄ requirements.txt           # Python dependencies
‚îú‚îÄ‚îÄ config_template.py         # Configuration template
‚îú‚îÄ‚îÄ aoi.geojson               # Area of interest
‚îú‚îÄ‚îÄ automate_processing.sh    # Automation script
‚îú‚îÄ‚îÄ output/                   # Generated maps
‚îî‚îÄ‚îÄ README.md                 # Documentation</code></pre>

            <p class="github-link">
                <a href="https://github.com/Cam-B33/port-stanley-bathymetry" target="_blank">
                    View on GitHub ‚Üí
                </a>
            </p>

            <h3>Contributing</h3>
            <p>Contributions welcome. This tool was developed for beach safety applications but can be adapted for coastal research, habitat mapping, and environmental monitoring.</p>

            <h3>License</h3>
            <p>MIT License. Free to use and modify for any purpose.</p>
        </section>
    </main>

    <footer>
        <p>Developed for lifeguard operations at Port Stanley Beach, Ontario</p>
        <p style="margin-top: 0.5rem;">Data: ESA Copernicus Sentinel-2 | Processing: Python + GDAL | Mapping: Leaflet.js</p>
    </footer>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Navigation
        const navLinks = document.querySelectorAll('.nav-link');
        const sections = {
            'dashboard': document.getElementById('dashboard-section'),
            'methodology': document.getElementById('methodology-section'),
            'code': document.getElementById('code-section')
        };

        navLinks.forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const targetSection = link.dataset.section;
                
                // Update active nav link
                navLinks.forEach(l => l.classList.remove('active'));
                link.classList.add('active');
                
                // Show/hide sections
                Object.keys(sections).forEach(key => {
                    if (key === targetSection) {
                        sections[key].classList.remove('hidden');
                    } else {
                        sections[key].classList.add('hidden');
                    }
                });
            });
        });

        // Initialize map (remove attribution from map)
        const map = L.map('map', {
            attributionControl: false,
            zoomControl: false  // We'll reposition this
        }).setView([42.6666, -81.2169], 15);
        
        // Add zoom control to top-left
        L.control.zoom({
            position: 'topleft'
        }).addTo(map);

        // Add base map
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors',
            maxZoom: 19
        }).addTo(map);

        // Add satellite layer option
        const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Esri, Maxar, Earthstar Geographics',
            maxZoom: 19
        });

        // Layer control
        const baseMaps = {
            "Street Map": L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }),
            "Satellite": satellite
        };

        // Layer control for base maps - position bottom left
        const layerControl = L.control.layers(baseMaps, null, {
            position: 'bottomleft'
        }).addTo(map);

        // Add bathymetry overlay - fine-tuned alignment
        const bathymetryBounds = [
            [42.6481, -81.2445],  // Southwest corner (moved back to original)
            [42.6633, -81.2119]   // Northeast corner (moved back to original)
        ];
        
        const bathymetryOverlay = L.imageOverlay(
            'maps/bathymetry_2024_09_30.png',
            bathymetryBounds,
            {
                opacity: 0.7,
                interactive: true
            }
        ).addTo(map);
        
        // Add to layer control so users can toggle it
        layerControl.addOverlay(bathymetryOverlay, "Bathymetry Overlay");
        
        // Also try to load dynamically for future updates
        fetch('maps_data.json')
            .then(response => response.json())
            .then(data => {
                console.log('Loaded maps data:', data);
                
                // Update the "Last updated" date
                if (data.latest) {
                    document.getElementById('last-update-date').textContent = data.latest.date;
                    
                    // Update bathymetry overlay to latest map
                    const newSrc = 'maps/' + data.latest.filename;
                    bathymetryOverlay.setUrl(newSrc);
                    console.log('Updated bathymetry to:', newSrc);
                }
                
                // Build image gallery
                const gallery = document.getElementById('image-gallery');
                if (gallery && data.maps && data.maps.length > 0) {
                    gallery.innerHTML = ''; // Clear loading text
                    
                    data.maps.forEach(map => {
                        const card = document.createElement('div');
                        card.style.cssText = 'border: 1px solid #ddd; border-radius: 8px; padding: 15px; margin-bottom: 15px; background: white;';
                        
                        card.innerHTML = `
                            <div style="display: flex; gap: 15px; align-items: start;">
                                <img src="maps/${map.filename}" 
                                     style="width: 200px; height: auto; border-radius: 4px; cursor: pointer;" 
                                     onclick="bathymetryOverlay.setUrl('maps/${map.filename}'); document.getElementById('last-update-date').textContent = '${map.date}';"
                                     alt="Bathymetry ${map.date}">
                                <div style="flex: 1;">
                                    <h4 style="margin: 0 0 8px 0;">${map.date}</h4>
                                    <p style="margin: 0 0 8px 0; color: #666;">${map.description}</p>
                                    <p style="margin: 0; font-size: 0.85rem; color: #999;">Added: ${new Date(map.added).toLocaleDateString()}</p>
                                    <button onclick="bathymetryOverlay.setUrl('maps/${map.filename}'); document.getElementById('last-update-date').textContent = '${map.date}';" 
                                            style="margin-top: 10px; padding: 6px 12px; background: #2563eb; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                        Load on Map
                                    </button>
                                </div>
                            </div>
                        `;
                        
                        gallery.appendChild(card);
                    });
                }
            })
            .catch(err => console.log('Maps data error:', err));

        // Add marker for Port Stanley Beach
        L.marker([42.6666, -81.2169])
            .addTo(map)
            .bindPopup('<b>Port Stanley Main Beach</b><br>Primary lifeguard station');

        // LIFEGUARD TOWERS
        const towerIcon = L.divIcon({
            className: 'tower-marker',
            html: '<div style="background: #ff4444; color: white; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">üõü</div>',
            iconSize: [28, 28],
            iconAnchor: [14, 14]
        });

        // Tower 1 (East)
        L.marker([42.658712889533405, -81.21593214409477], {icon: towerIcon})
            .addTo(map)
            .bindPopup('<b>Tower 1</b><br>East end of swim zone');

        // Tower 2
        L.marker([42.65912810039798, -81.21743552224498], {icon: towerIcon})
            .addTo(map)
            .bindPopup('<b>Tower 2</b>');

        // Central Tower
        const centralIcon = L.divIcon({
            className: 'tower-marker',
            html: '<div style="background: #ff4444; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 14px; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.4);">‚õ±Ô∏è</div>',
            iconSize: [32, 32],
            iconAnchor: [16, 16]
        });
        
        L.marker([42.65961530391666, -81.21815435426022], {icon: centralIcon})
            .addTo(map)
            .bindPopup('<b>Central Tower</b><br>Main lifeguard station');

        // Tower 3
        L.marker([42.65954281537943, -81.21897376911585], {icon: towerIcon})
            .addTo(map)
            .bindPopup('<b>Tower 3</b>');

        // Tower 4 (West)
        L.marker([42.65995506200763, -81.22060991661222], {icon: towerIcon})
            .addTo(map)
            .bindPopup('<b>Tower 4</b><br>West end of swim zone');

        // DESIGNATED SWIM ZONE
        const swimZone = L.polygon([
            [42.658712889533405, -81.21593214409477],  // NE (T1 shore)
            [42.65995506200763, -81.22060991661222],   // NW (T4 shore)
            [42.658607595245144, -81.22060991661222],  // SW (T4 offshore, 150m)
            [42.657365422770916, -81.21593214409477]   // SE (T1 offshore, 150m)
        ], {
            color: '#00ff00',
            fillColor: '#00ff00',
            fillOpacity: 0.15,
            weight: 3,
            dashArray: '10, 10',
            interactive: true
        }).addTo(map);
        
        swimZone.bindPopup('<b>Designated Swim Zone</b><br>Patrolled by lifeguards<br>Extends 150m offshore');
        
        // Add swim zone to layer control
        layerControl.addOverlay(swimZone, "Swim Zone");

        // Load recent images dynamically
        const recentImages = [
            {
                src: 'output/port_stanley_sept_30_2024.png',
                caption: 'September 30, 2024 ‚Äî Clear rip channels visible on east side'
            }
            // Add more images as they're generated
        ];

        const gallery = document.getElementById('image-gallery');
        recentImages.forEach(img => {
            const figure = document.createElement('figure');
            figure.className = 'image-card';
            figure.innerHTML = `
                <img src="${img.src}" alt="${img.caption}" onerror="this.parentElement.style.display='none'">
                <figcaption>${img.caption}</figcaption>
            `;
            gallery.appendChild(figure);
        });

        // ========================================================================
        // INTERACTIVE RIP CURRENT HEAT MAP
        // ========================================================================
        
        const flowCanvas = document.getElementById('flow-canvas');
        const flowCtx = flowCanvas.getContext('2d');
        let flowMode = 'off';
        let riskZones = null;  // Will hold risk data
        
        // Load risk zone data
        fetch('maps/rip_risk_zones.json')
            .then(response => response.json())
            .then(data => {
                riskZones = data;
                console.log('Loaded risk zones:', data.metadata);
            })
            .catch(err => console.log('Risk zones not found, heat map disabled'));
        
        // Resize canvas to match map
        function resizeCanvas() {
            const mapElement = document.getElementById('map');
            flowCanvas.width = mapElement.offsetWidth;
            flowCanvas.height = mapElement.offsetHeight;
            drawHeatMap();  // Redraw when resized
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        map.on('zoom move', resizeCanvas);
        
        // Draw heat map based on current flow mode
        function drawHeatMap() {
            if (flowMode === 'off' || !riskZones) {
                flowCtx.clearRect(0, 0, flowCanvas.width, flowCanvas.height);
                return;
            }
            
            flowCtx.clearRect(0, 0, flowCanvas.width, flowCanvas.height);
            
            // Get risk zones for current direction
            const zones = riskZones.risk_zones[flowMode];
            if (!zones || zones.length === 0) return;
            
            // Draw each risk cell as a colored square
            zones.forEach(zone => {
                const point = map.latLngToContainerPoint([zone.lat, zone.lon]);
                
                // Color based on risk level (0-1)
                // Green (safe) ‚Üí Yellow ‚Üí Orange ‚Üí Red (danger)
                let r, g, b;
                if (zone.risk < 0.25) {
                    // Green to yellow
                    r = Math.floor(zone.risk * 4 * 255);
                    g = 255;
                    b = 0;
                } else if (zone.risk < 0.5) {
                    // Yellow to orange
                    r = 255;
                    g = Math.floor((1 - (zone.risk - 0.25) * 4) * 255);
                    b = 0;
                } else if (zone.risk < 0.75) {
                    // Orange to red
                    r = 255;
                    g = Math.floor((1 - (zone.risk - 0.5) * 4) * 128);
                    b = 0;
                } else {
                    // Deep red
                    r = 255;
                    g = 0;
                    b = 0;
                }
                
                // Larger cells with blur for fuzzy continuous effect
                const cellSize = 35;  // Increased from 20 to 35
                
                // Add gaussian blur effect
                flowCtx.shadowBlur = 25;  // Strong blur
                flowCtx.shadowColor = `rgba(${r}, ${g}, ${b}, ${0.6 + zone.risk * 0.4})`;
                
                // Draw main cell
                flowCtx.fillStyle = `rgba(${r}, ${g}, ${b}, ${0.3 + zone.risk * 0.5})`;
                flowCtx.fillRect(
                    point.x - cellSize/2,
                    point.y - cellSize/2,
                    cellSize,
                    cellSize
                );
                
                // Draw inner glow for high risk
                if (zone.risk > 0.5) {
                    flowCtx.shadowBlur = 35;
                    flowCtx.fillStyle = `rgba(${r}, ${g}, ${b}, ${zone.risk * 0.4})`;
                    flowCtx.fillRect(
                        point.x - cellSize/2,
                        point.y - cellSize/2,
                        cellSize,
                        cellSize
                    );
                }
                
                // Reset shadow
                flowCtx.shadowBlur = 0;
            });
        }
        
        // Handle flow mode changes
        document.querySelectorAll('input[name="flow-mode"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                flowMode = e.target.value;
                drawHeatMap();
            });
        });
    </script>
</body>
</html>
