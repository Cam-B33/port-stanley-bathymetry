<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Port Stanley Nearshore Bathymetry</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Computer+Modern+Serif:wght@400;700&family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #fefefe;
            --bg-secondary: #f8f8f8;
            --text-primary: #1a1a1a;
            --text-secondary: #555;
            --accent: #2563eb;
            --border: #ddd;
            --code-bg: #f5f5f5;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Computer Modern Serif', 'Georgia', serif;
            line-height: 1.7;
            color: var(--text-primary);
            background: var(--bg-primary);
            max-width: 1200px;
            margin: 0 auto;
            padding: 3rem 2rem;
        }
        
        header {
            border-bottom: 2px solid var(--text-primary);
            padding-bottom: 1.5rem;
            margin-bottom: 3rem;
        }
        
        h1 {
            font-size: 2.2rem;
            font-weight: 700;
            letter-spacing: -0.02em;
            margin-bottom: 0.5rem;
        }
        
        .subtitle {
            font-size: 1.1rem;
            color: var(--text-secondary);
            font-style: italic;
        }
        
        nav {
            margin-top: 1.5rem;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9rem;
        }
        
        nav a {
            color: var(--text-primary);
            text-decoration: none;
            margin-right: 2rem;
            border-bottom: 1px solid transparent;
            transition: border-color 0.2s;
        }
        
        nav a:hover,
        nav a.active {
            border-bottom: 1px solid var(--text-primary);
        }
        
        main {
            margin-bottom: 4rem;
        }
        
        section {
            margin-bottom: 4rem;
        }
        
        h2 {
            font-size: 1.6rem;
            margin-bottom: 1rem;
            font-weight: 700;
        }
        
        h3 {
            font-size: 1.2rem;
            margin: 1.5rem 0 0.75rem;
            font-weight: 600;
        }
        
        p {
            margin-bottom: 1rem;
        }
        
        .map-container {
            width: 100%;
            height: 600px;
            border: 1px solid var(--border);
            margin: 2rem 0;
            position: relative;
        }
        
        #map {
            width: 100%;
            height: 100%;
        }
        
        .map-info {
            background: var(--bg-secondary);
            padding: 1.5rem;
            border-left: 3px solid var(--accent);
            margin: 1.5rem 0;
        }
        
        .map-info h3 {
            margin-top: 0;
        }
        
        .date-updated {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        code {
            font-family: 'IBM Plex Mono', monospace;
            background: var(--code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-size: 0.9em;
        }
        
        pre {
            font-family: 'IBM Plex Mono', monospace;
            background: var(--code-bg);
            padding: 1.5rem;
            border-radius: 4px;
            overflow-x: auto;
            margin: 1.5rem 0;
            border-left: 3px solid var(--accent);
        }
        
        pre code {
            background: none;
            padding: 0;
        }
        
        .theorem {
            background: var(--bg-secondary);
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 3px solid var(--text-primary);
        }
        
        .theorem-title {
            font-weight: 600;
            font-style: italic;
            margin-bottom: 0.5rem;
        }
        
        a {
            color: var(--accent);
            text-decoration: none;
            border-bottom: 1px solid transparent;
        }
        
        a:hover {
            border-bottom: 1px solid var(--accent);
        }
        
        footer {
            border-top: 1px solid var(--border);
            padding-top: 2rem;
            margin-top: 4rem;
            font-size: 0.9rem;
            color: var(--text-secondary);
            text-align: center;
        }
        
        .github-link {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9rem;
        }
        
        .image-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin: 2rem 0;
        }
        
        .image-card {
            border: 1px solid var(--border);
            overflow: hidden;
        }
        
        .image-card img {
            width: 100%;
            display: block;
        }
        
        .image-card figcaption {
            padding: 1rem;
            font-size: 0.9rem;
            color: var(--text-secondary);
            background: var(--bg-secondary);
        }
        
        .hidden {
            display: none;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 2rem 1rem;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            nav a {
                display: block;
                margin: 0.5rem 0;
            }
            
            .map-container {
                height: 400px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Port Stanley Nearshore Bathymetry</h1>
        <p class="subtitle">Satellite-derived rip current mapping for beach safety</p>
        <nav>
            <a href="#" class="nav-link active" data-section="dashboard">Dashboard</a>
            <a href="#" class="nav-link" data-section="methodology">Methodology</a>
            <a href="#" class="nav-link" data-section="code">Code</a>
        </nav>
    </header>

    <main>
        <!-- Dashboard Section -->
        <section id="dashboard-section">
            <h2>Current Bathymetry Map</h2>
            
            <div class="map-info">
                <h3>Lake Erie — Port Stanley Main Beach</h3>
                <p class="date-updated">Last updated: <strong id="last-update-date">2024-09-30</strong></p>
                <p>This map shows relative nearshore bathymetry derived from Sentinel-2 satellite imagery. Darker channels indicate deeper water where rip currents are likely to form.</p>
            </div>

            <div class="map-container">
                <div id="map"></div>
                <canvas id="flow-canvas" style="position: absolute; top: 0; left: 0; pointer-events: none; z-index: 1000;"></canvas>
                
                <!-- Flow Control Panel -->
                <div id="flow-controls" style="position: absolute; top: 10px; right: 60px; background: white; padding: 15px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.2); z-index: 1001; font-family: 'IBM Plex Mono', monospace; font-size: 0.85rem;">
                    <div style="margin-bottom: 10px; font-weight: 600;">Rip Current Flow</div>
                    <label style="display: block; margin-bottom: 8px; cursor: pointer;">
                        <input type="radio" name="flow-mode" value="off" checked> Off
                    </label>
                    <label style="display: block; margin-bottom: 8px; cursor: pointer;">
                        <input type="radio" name="flow-mode" value="east"> East Current
                    </label>
                    <label style="display: block; margin-bottom: 8px; cursor: pointer;">
                        <input type="radio" name="flow-mode" value="west"> West Current
                    </label>
                    <label style="display: block; margin-bottom: 8px; cursor: pointer;">
                        <input type="radio" name="flow-mode" value="offshore"> Offshore Flow
                    </label>
                    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #ddd; font-size: 0.75rem; color: #666;">
                        Shows water flow direction<br>based on bathymetry
                    </div>
                </div>
            </div>

            <div class="map-info">
                <h3>Reading the Map</h3>
                <p><strong>Light areas:</strong> Shallow water (sandbars)</p>
                <p><strong>Dark channels:</strong> Deeper water where rip currents typically flow</p>
                <p><strong>Purple contours:</strong> Depth intervals showing underwater topography</p>
            </div>

            <h3>Recent Imagery</h3>
            <div class="image-gallery" id="image-gallery">
                <!-- Images will be dynamically loaded here -->
            </div>
        </section>

        <!-- Methodology Section -->
        <section id="methodology-section" class="hidden">
            <h2>Methodology</h2>
            
            <h3>Overview</h3>
            <p>This project uses multispectral satellite imagery from the European Space Agency's Sentinel-2 constellation to map shallow water bathymetry. The technique exploits differential light penetration through water columns of varying depths.</p>

            <div class="theorem">
                <div class="theorem-title">Band Ratio Method</div>
                <p>Relative depth <em>Z</em> is approximated as:</p>
                <p style="text-align: center; margin: 1rem 0; font-style: italic;">
                    Z ≈ ln(R<sub>green</sub>) / ln(R<sub>red</sub>)
                </p>
                <p>where R denotes reflectance in each spectral band.</p>
            </div>

            <h3>Physical Principles</h3>
            <p>Water absorbs light differentially by wavelength. Red light (620-670 nm) is absorbed more rapidly than green light (530-590 nm). In shallow water, bottom reflectance contributes to the upwelling radiance measured by the satellite sensor.</p>
            
            <p>The ratio of logarithmic reflectances normalizes for variations in water clarity and illumination while remaining sensitive to depth variations in the 0-10m range typical of nearshore environments.</p>

            <h3>Data Processing Pipeline</h3>
            <ol style="margin-left: 2rem;">
                <li><strong>Acquisition:</strong> Sentinel-2 Level-2A (atmospherically corrected) imagery at 10m spatial resolution</li>
                <li><strong>Band Selection:</strong> Blue (B02), Green (B03), and Red (B04) bands</li>
                <li><strong>Ratio Calculation:</strong> Log-ratio bathymetry algorithm</li>
                <li><strong>Clipping:</strong> Extract area of interest around Port Stanley Beach</li>
                <li><strong>Visualization:</strong> Generate contoured maps highlighting rip current pathways</li>
            </ol>

            <h3>Applications to Beach Safety</h3>
            <p>Channelized rip currents preferentially form in deeper channels between shallow sandbars. These maps allow lifeguards to:</p>
            <ul style="margin-left: 2rem;">
                <li>Identify high-risk zones for rip current formation</li>
                <li>Position towers and patrols strategically</li>
                <li>Adjust swim zones based on current bathymetric conditions</li>
                <li>Track morphological changes throughout the summer season</li>
            </ul>

            <h3>Limitations</h3>
            <p>This method provides <em>relative</em> rather than absolute depth measurements. Accuracy degrades with increasing turbidity, wave action, and sun glint. Cloud cover precludes data acquisition. Temporal resolution is limited by satellite revisit frequency (5 days for Sentinel-2 constellation).</p>

            <h3>References</h3>
            <p style="margin-left: 2rem; text-indent: -2rem; padding-left: 2rem;">
                Stumpf, R. P., Holderied, K., & Sinclair, M. (2003). Determination of water depth with high-resolution satellite imagery over variable bottom types. <em>Limnology and Oceanography</em>, 48(1), 547-556.
            </p>
            <p style="margin-left: 2rem; text-indent: -2rem; padding-left: 2rem;">
                Lyzenga, D. R. (1978). Passive remote sensing techniques for mapping water depth and bottom features. <em>Applied Optics</em>, 17(3), 379-383.
            </p>
        </section>

        <!-- Code Section -->
        <section id="code-section" class="hidden">
            <h2>Open Source Implementation</h2>
            
            <p>The complete processing pipeline is available as an open-source Python command-line tool. The code is designed to be reproducible and easily adaptable to other nearshore environments.</p>

            <h3>Installation</h3>
            <pre><code># Clone repository
git clone https://github.com/Cam-B33/port-stanley-bathymetry.git
cd port-stanley-bathymetry

# Install dependencies
pip install -r requirements.txt</code></pre>

            <h3>Basic Usage</h3>
            <pre><code># Process a Sentinel-2 scene
python sentinel_bathymetry.py process \
    --scene /path/to/S2_SAFE_folder \
    --aoi aoi.geojson \
    --output port_stanley_2024_06_10</code></pre>

            <h3>Automated Processing</h3>
            <p>The system can automatically download and process new imagery every 10 days:</p>
            <pre><code># Download and process recent imagery
python sentinel_bathymetry.py download-and-process \
    --aoi aoi.geojson \
    --start-date 20240601 \
    --end-date 20240610 \
    --username your_copernicus_username \
    --password your_password</code></pre>

            <h3>Key Dependencies</h3>
            <ul style="margin-left: 2rem;">
                <li><code>rasterio</code> — Geospatial raster I/O</li>
                <li><code>numpy</code> — Numerical computing</li>
                <li><code>sentinelsat</code> — Sentinel-2 data access</li>
                <li><code>matplotlib</code> — Visualization</li>
            </ul>

            <h3>Repository Structure</h3>
            <pre><code>port-stanley-bathymetry/
├── sentinel_bathymetry.py    # Main processing script
├── requirements.txt           # Python dependencies
├── config_template.py         # Configuration template
├── aoi.geojson               # Area of interest
├── automate_processing.sh    # Automation script
├── output/                   # Generated maps
└── README.md                 # Documentation</code></pre>

            <p class="github-link">
                <a href="https://github.com/Cam-B33/port-stanley-bathymetry" target="_blank">
                    View on GitHub →
                </a>
            </p>

            <h3>Contributing</h3>
            <p>Contributions welcome. This tool was developed for beach safety applications but can be adapted for coastal research, habitat mapping, and environmental monitoring.</p>

            <h3>License</h3>
            <p>MIT License. Free to use and modify for any purpose.</p>
        </section>
    </main>

    <footer>
        <p>Developed for lifeguard operations at Port Stanley Beach, Ontario</p>
        <p style="margin-top: 0.5rem;">Data: ESA Copernicus Sentinel-2 | Processing: Python + GDAL | Mapping: Leaflet.js</p>
    </footer>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Navigation
        const navLinks = document.querySelectorAll('.nav-link');
        const sections = {
            'dashboard': document.getElementById('dashboard-section'),
            'methodology': document.getElementById('methodology-section'),
            'code': document.getElementById('code-section')
        };

        navLinks.forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const targetSection = link.dataset.section;
                
                // Update active nav link
                navLinks.forEach(l => l.classList.remove('active'));
                link.classList.add('active');
                
                // Show/hide sections
                Object.keys(sections).forEach(key => {
                    if (key === targetSection) {
                        sections[key].classList.remove('hidden');
                    } else {
                        sections[key].classList.add('hidden');
                    }
                });
            });
        });

        // Initialize map
        const map = L.map('map').setView([42.6666, -81.2169], 15);

        // Add base map
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors',
            maxZoom: 19
        }).addTo(map);

        // Add satellite layer option
        const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Esri, Maxar, Earthstar Geographics',
            maxZoom: 19
        });

        // Layer control
        const baseMaps = {
            "Street Map": L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }),
            "Satellite": satellite
        };

        // Layer control for base maps
        const layerControl = L.control.layers(baseMaps).addTo(map);

        // Add bathymetry overlay - manually adjusted for alignment
        const bathymetryBounds = [
            [42.6470, -81.2430],  // Southwest corner - shifted east and south
            [42.6622, -81.2104]   // Northeast corner - shifted east and south
        ];
        
        const bathymetryOverlay = L.imageOverlay(
            'maps/bathymetry_2024_09_30.png',
            bathymetryBounds,
            {
                opacity: 0.7,
                interactive: true
            }
        ).addTo(map);
        
        // Add to layer control so users can toggle it
        layerControl.addOverlay(bathymetryOverlay, "Bathymetry Overlay");
        
        // Also try to load dynamically for future updates
        fetch('maps_data.json')
            .then(response => response.json())
            .then(data => {
                console.log('Loaded maps data:', data);
                if (data.latest && data.latest.filename) {
                    // Update the overlay source if different
                    const newSrc = 'maps/' + data.latest.filename;
                    console.log('Setting bathymetry to:', newSrc);
                }
            })
            .catch(err => console.log('Maps data error:', err));

        // Add marker for Port Stanley Beach
        L.marker([42.6666, -81.2169])
            .addTo(map)
            .bindPopup('<b>Port Stanley Main Beach</b><br>Primary lifeguard station');

        // Placeholder swim zone
        const swimZone = [
            [42.6655, -81.2180],
            [42.6640, -81.2150],
            [42.6635, -81.2155],
            [42.6650, -81.2185]
        ];
        
        L.polygon(swimZone, {
            color: 'purple',
            fillColor: 'purple',
            fillOpacity: 0.2,
            weight: 2
        }).addTo(map).bindPopup('Designated swim area');

        // Load recent images dynamically
        const recentImages = [
            {
                src: 'output/port_stanley_sept_30_2024.png',
                caption: 'September 30, 2024 — Clear rip channels visible on east side'
            }
            // Add more images as they're generated
        ];

        const gallery = document.getElementById('image-gallery');
        recentImages.forEach(img => {
            const figure = document.createElement('figure');
            figure.className = 'image-card';
            figure.innerHTML = `
                <img src="${img.src}" alt="${img.caption}" onerror="this.parentElement.style.display='none'">
                <figcaption>${img.caption}</figcaption>
            `;
            gallery.appendChild(figure);
        });

        // ========================================================================
        // ANIMATED FLOW VISUALIZATION WITH BATHYMETRY
        // ========================================================================
        
        const flowCanvas = document.getElementById('flow-canvas');
        const flowCtx = flowCanvas.getContext('2d');
        let flowMode = 'off';
        let particles = [];
        let animationFrame = null;
        let depthGrid = null;  // Will hold bathymetry flow data
        
        // Load depth grid data
        fetch('maps/depth_grid.json')
            .then(response => response.json())
            .then(data => {
                depthGrid = data;
                console.log('Loaded depth grid:', data.grid_size);
            })
            .catch(err => console.log('Depth grid not found, using simple flow'));
        
        // Resize canvas to match map
        function resizeCanvas() {
            const mapElement = document.getElementById('map');
            flowCanvas.width = mapElement.offsetWidth;
            flowCanvas.height = mapElement.offsetHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        map.on('zoom move', resizeCanvas);
        
        // Get flow direction at a specific lat/lon from depth grid
        function getFlowAtLocation(lat, lon) {
            if (!depthGrid) return { flow_x: 0, flow_y: 0 };
            
            const grid = depthGrid.grid;
            const bounds = depthGrid.bounds;
            
            // Convert lat/lon to grid coordinates
            const rows = depthGrid.grid_size.rows;
            const cols = depthGrid.grid_size.cols;
            
            // Normalize to 0-1
            const normLat = (lat - bounds.south) / (bounds.north - bounds.south);
            const normLon = (lon - bounds.west) / (bounds.east - bounds.west);
            
            // Convert to grid indices
            const gridRow = Math.floor(normLat * (rows - 1));
            const gridCol = Math.floor(normLon * (cols - 1));
            
            // Bounds check
            if (gridRow < 0 || gridRow >= rows || gridCol < 0 || gridCol >= cols) {
                return { flow_x: 0, flow_y: 0 };
            }
            
            const cell = grid[gridRow][gridCol];
            return {
                flow_x: cell.flow_x || 0,
                flow_y: cell.flow_y || 0,
                depth: cell.depth
            };
        }
        
        // Particle class for bathymetry-aware flow animation
        class FlowParticle {
            constructor(lat, lon, direction) {
                this.lat = lat;
                this.lon = lon;
                this.direction = direction;  // 'east', 'west', or 'offshore'
                this.age = 0;
                this.maxAge = 150 + Math.random() * 150;
                this.baseSpeed = 0.00008;
                this.opacity = 0;
            }
            
            update() {
                this.age++;
                
                // Fade in/out
                if (this.age < 30) {
                    this.opacity = this.age / 30;
                } else if (this.age > this.maxAge - 30) {
                    this.opacity = (this.maxAge - this.age) / 30;
                } else {
                    this.opacity = 1;
                }
                
                // Get bathymetry-based flow direction at current location
                const bathyFlow = getFlowAtLocation(this.lat, this.lon);
                
                // Combine bathymetry flow with current direction
                let flowLat = bathyFlow.flow_y * 0.00003;  // Bathymetry influence
                let flowLon = bathyFlow.flow_x * 0.00003;
                
                // Add directional bias based on current mode
                if (this.direction === 'east') {
                    flowLon += this.baseSpeed * 1.5;  // Strong eastward bias
                    flowLat += bathyFlow.flow_y * 0.00005;  // Bathymetry pulls toward channels
                } else if (this.direction === 'west') {
                    flowLon -= this.baseSpeed * 1.5;  // Strong westward bias
                    flowLat += bathyFlow.flow_y * 0.00005;
                } else if (this.direction === 'offshore') {
                    // Offshore flow: bathymetry dominates (flows down channels)
                    flowLat = bathyFlow.flow_y * 0.0001;
                    flowLon = bathyFlow.flow_x * 0.0001;
                    // Add slight offshore bias
                    flowLat -= this.baseSpeed * 0.5;
                }
                
                // Update position
                this.lat += flowLat;
                this.lon += flowLon;
                
                return this.age < this.maxAge;
            }
            
            draw() {
                const point = map.latLngToContainerPoint([this.lat, this.lon]);
                
                // Get flow at this location for coloring
                const bathyFlow = getFlowAtLocation(this.lat, this.lon);
                const flowMagnitude = Math.sqrt(bathyFlow.flow_x**2 + bathyFlow.flow_y**2);
                
                // Color based on flow strength (stronger = brighter red)
                const intensity = Math.min(255, 100 + flowMagnitude * 300);
                
                // Draw particle
                flowCtx.beginPath();
                flowCtx.arc(point.x, point.y, 2.5, 0, Math.PI * 2);
                flowCtx.fillStyle = `rgba(${intensity}, 50, 50, ${this.opacity * 0.9})`;
                flowCtx.fill();
                
                // Draw trail showing direction
                const trailLength = 20;
                const bathyFlow2 = getFlowAtLocation(this.lat, this.lon);
                const trailLat = this.lat - bathyFlow2.flow_y * 0.0002 * trailLength;
                const trailLon = this.lon - bathyFlow2.flow_x * 0.0002 * trailLength;
                
                const trailPoint = map.latLngToContainerPoint([trailLat, trailLon]);
                
                flowCtx.beginPath();
                flowCtx.moveTo(trailPoint.x, trailPoint.y);
                flowCtx.lineTo(point.x, point.y);
                flowCtx.strokeStyle = `rgba(${intensity}, 50, 50, ${this.opacity * 0.4})`;
                flowCtx.lineWidth = 2;
                flowCtx.stroke();
            }
        }
        
        // Generate particles based on bathymetry
        function generateParticles(direction) {
            particles = [];
            
            // Generate particles in a grid covering the bathymetry area
            const bounds = map.getBounds();
            const bathyBounds = {
                south: 42.648125,
                west: -81.244475,
                north: 42.663265,
                east: -81.211917
            };
            
            // Only generate particles in the bathymetry area
            const latStep = (bathyBounds.north - bathyBounds.south) / 15;
            const lonStep = (bathyBounds.east - bathyBounds.west) / 25;
            
            for (let lat = bathyBounds.south; lat < bathyBounds.north; lat += latStep) {
                for (let lon = bathyBounds.west; lon < bathyBounds.east; lon += lonStep) {
                    // Add some randomness
                    const jitterLat = (Math.random() - 0.5) * latStep;
                    const jitterLon = (Math.random() - 0.5) * lonStep;
                    
                    particles.push(new FlowParticle(
                        lat + jitterLat,
                        lon + jitterLon,
                        direction
                    ));
                }
            }
        }
        
        // Animation loop
        function animateFlow() {
            if (flowMode === 'off') {
                flowCtx.clearRect(0, 0, flowCanvas.width, flowCanvas.height);
                if (animationFrame) {
                    cancelAnimationFrame(animationFrame);
                    animationFrame = null;
                }
                return;
            }
            
            // Clear canvas
            flowCtx.clearRect(0, 0, flowCanvas.width, flowCanvas.height);
            
            // Update and draw particles
            particles = particles.filter(p => p.update());
            particles.forEach(p => p.draw());
            
            // Regenerate particles if running low
            if (particles.length < 100) {
                generateParticles(flowMode);
            }
            
            animationFrame = requestAnimationFrame(animateFlow);
        }
        
        // Handle flow mode changes
        document.querySelectorAll('input[name="flow-mode"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                flowMode = e.target.value;
                
                if (flowMode === 'off') {
                    particles = [];
                    flowCtx.clearRect(0, 0, flowCanvas.width, flowCanvas.height);
                } else {
                    generateParticles(flowMode);
                    if (!animationFrame) {
                        animateFlow();
                    }
                }
            });
        });
    </script>
</body>
</html>
